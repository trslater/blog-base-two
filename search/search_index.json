{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About This Blog","text":"<p>There is a great deal of traditional math and science education on the internet. Much of it is very good, but I find there is a lack of material focusing on getting a feeling for a concept separate from the math or mechanics of the process. When there is, it is rarely interactive. There is Brilliant.org, but is behind a paywall.</p> <p>My goal with this blog is to take a problem-driven approach to mathematical discovery through starting from something simple or well understood and building up in natural-feeling steps to an intuitive understanding of the problem. My experience has been that if you work through material and try to visualize what is going on, you remember it better, and can apply it more broadly than if you just memorize how to perform a set of tasks.</p> <p>This is a blog primarily about math and computer science, but I may also include other topics from time to time, such as electrical engineering, physics, and music theory.</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#computer-graphics","title":"Computer Graphics","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> <li>Splines 1: A Spline-Tingling Idea</li> </ul>"},{"location":"tags/#linear-algebra","title":"Linear Algebra","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> <li>Splines 1: A Spline-Tingling Idea</li> </ul>"},{"location":"tags/#some","title":"SoME","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> </ul>"},{"location":"tags/#some3","title":"SoME3","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> </ul>"},{"location":"2023/07/13/improved-blogging-experience/","title":"Improved Blogging Experience","text":"<p>MkDocs Material (the amazing MkDocs theme that powers this site) has hit their $12,000 goal, which means they have made their blogging platform available to non-insiders! It is still in beta, but I decided to go for it anyway, because I really wanted my blog to feel more like a real blog.</p> <p>There is one wrinkle: it is not compatible with the Jupyter MkDocs plugin I was using, so for now, my old posts (which were Jupyter notebooks) have been taken down. I plan to convert them to Markdown at some point, but for now, the blog just has this one post.</p>"},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/","title":"M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle","text":"\"Path tracing 001.png\" by Qutorial is licensed under CC BY-SA 4.0 <p>Have you ever wondered how computers produce photorealistic lighting: shading, shadows, reflections, depth of field, etc.? Most commonly, this is done via ray tracing or one of its descendants (e.g., path tracing or photon mapping). The basic idea is to mimic the way rays of light travel around a scene and what colour the ray is when it reaches the eye/camera. There are many ways light rays interact within a scene, but they almost all require knowing where a ray hits an object. From this point it can bounce off, refract through, or be used to simulate the effect of many rays spraying out in all directions. This article will focus ray collisions with the most general of objects: the humble triangle. We will start with an intuitive understanding of the problem and work our way up to an elegant and efficient solution known as the M\u00f6ller\u2013Trumbore algorithm.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#requisite-knowledge","title":"Requisite Knowledge","text":"<p>This article should be well understood by anyone with a highschool math education. An understanding of vectors and vector operations (addition, subtraction, dot product, etc.) is probably required as well. There is some linear algebra, but I explain the notation and operations at a high level, and we don't actually perform any computations, so previous knowledge of linear algebra probably isn't necessary, though an understanding of very basic concepts couldn't hurt.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#discriminating-between-points-vectors","title":"Discriminating Between Points &amp; Vectors","text":"<p>Something that is not commonly taught unless you are specifically learning about graphics is to consider points and vectors as distinct from one another. Generally, any coordinate can be considered a point or vector interchangeably. Mathematically, the distinction isn't strictly necessary, but I find it useful, especially when modelling physical space\u2014commonly the case in computer graphics. I also find that there is a lack of consistent conventions surrounding this distinction, so I think it is worth providing a primer on how these concepts and notation will be used in this article.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#notation","title":"Notation","text":"<p>The notation I use can be summarize in the following table:</p> Quantity Bold Italic Uppercase Example Scalar X \\(t\\) Point X X \\(P\\) Vector X \\(\\mathbf{u}\\) Unit Vector X \\(\\mathbf{\\hat{u}}\\) Matrix X X \\(\\mathbf{A}\\)","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#definitions-operations","title":"Definitions &amp; Operations","text":"<p>A vector is a direction and distance. More generally, the distance is referred to as \"magnitude,\" but because it is more intuitive when modelling physical spaces, I'll generally refer to the magnitude of a vector as its \"distance.\" Vectors can be added, subtracted, and multiplied together (dot, cross, or matrix multiplication). Vectors can also be scaled by a real number, i.e., a scalar.</p> <p>A point is a location in space. It has no sense of direction or distance. The only operation that makes sense between two points is subtraction (think through the other operations and see if you can see why they don't make sense). This results in a vector that represents the distance between two points and the direction from one to the other. This simple relationship encapsulates all the ways points and vectors can be combined:</p> \\[\\begin{equation}     B - A = \\mathbf{u} \\end{equation}\\] <p>In this equation, the direction points from \\(A\\) to \\(B\\). What about going from \\(B\\) to \\(A\\)? Consider the following equations:</p> \\[\\begin{gather*}     A - B = -\\mathbf{u} \\\\     ||A - B|| = ||B - A|| \\end{gather*}\\] <p>Swapping the minuend and the subtrahend results in a vector pointing in the opposite direction. Note: this is notated with a negative sign (this can be thought of as the vector being scaled by -1). However, the distance between two points is the same whether pointing from \\(A\\) to \\(B\\) or \\(B\\) to \\(A\\). This should all make fairly intuitive sense. Bob has to run in the opposite direction to reach Alice that Alice would need to run to reach Bob, but their distance from one another is the same from either vantage point.</p> <p>Another key relationship to understand is the following:</p> \\[\\mathbf{u} = ||\\mathbf{u}||\\mathbf{\\hat{u}}\\] <p>This encapsulates how a vector can be decomposed into distance and direction, a very useful tool to have. Rearranging this also shows us how to compute a unit vector:</p> \\[\\mathbf{\\hat{u}} = \\frac{\\mathbf{u}}{||\\mathbf{u}||}\\] Can you divide by a vector? <p>It is interesting to think about the following:</p> \\[||\\mathbf{u}|| = \\frac{\\mathbf{u}}{\\mathbf{\\hat{u}}}\\] <p>Generally, we don't have a notion of dividing by a vector, but here it seems to make sense. I'll leave it to you to ponder.</p> <p>To me, these two relationships are some of the most useful to keep in mind when working with mathematical models of physical space.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#visualizing-vectors","title":"Visualizing Vectors","text":"<p>Vectors are often depicted as arrows originating at the origin, but this is misleading. In reality, there isn't a good visual representation of a vector\u2014at least in relation to other objects\u2014because they have no location. An object needs to exist at a location for you to draw it. Thus, there are always two implicit points when drawing a vector: the origin and the destination. This relationship can be understood better by rearranging the point difference equation and combining it with the vector decomposition equation:</p> \\[B = A + ||\\mathbf{u}||\\mathbf{\\hat{u}}\\] <p>This equation reads, if we start at position \\(A\\) and travel in direction \\(\\mathbf{\\hat{u}}\\) for a distance of \\(||\\mathbf{u}||\\), we will end up at position \\(B\\). In this sense, \\(\\mathbf{u}\\) can be thought of as the path such that if you follow it from \\(A\\) you will arrive at \\(B\\). This may seem pedantic, but isn't that what math is all about? All kidding aside, it matters. For one thing, if we always think of a vector starting at the origin, it can be hard to make sense of vectors that represent things like forces that act on a particular location. Additionally, moving vectors around can give helpful insights to a problem.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#why-triangles","title":"Why Triangles?","text":"<p>Before we get started, a question might be popping out at you: why does a triangle represent a the most general case of an object in a 3D scene? Without getting into too much detail, any 3D surface can be approximated arbitrarily well using a mesh of triangles. Why not rectangles, pentagons, etc.? That is out of the scope of this article, but it has been found to greatly simplify storage and calculations of meshes. What is important for this article is that the vast majority of 3D objects are modelled as meshes of triangles. Therefore, knowing where a ray hits a single triangle is the same as knowing where a ray hits any arbitrary 3D surface\u2014at least to a good approximation. To collect the data of ray collisions across any number of objects and rays is as simple as\u2014glossing over some technicalities of course\u2014iterating over the triangles in a scene for each ray.</p> <p></p> \"Dolphin triangle mesh.png\" by Chrschn is licensed under public domain","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#2d-mollertrumbore","title":"2D M\u00f6ller\u2013Trumbore","text":"<p>With all of the preamble out of the way, it is time to start tackling our problem. However, as is usually the case with any new math problem, solving a simpler version of problem first is usually helpful in finding the final solution. When it comes to 3D graphics problems, this often means solving its 2D analog. 2D environments are simpler, easier to understand, and require a lot less algebra and computing power when modelling with code. Perhaps most importantly though, visual representations are almost always easier to parse. It may seem like extra work, but it often turns out to be less work to start in 2D and translate the solution to 3D than to start in 3D.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#translating-mollertrumbore-to-2d","title":"Translating M\u00f6ller\u2013Trumbore to 2D","text":"<p>At first, it might be tempting to think we can just shoot a 2D ray at a triangle lying in the 2D plane. After all, isn't a triangle already a 2D shape? It is, but we are not simply looking to find an analogous shape, but an analogous problem. For one, in 2D space, the triangle and ray always live on the same plane which is vanishingly unlikely in 3D. Conceptually, it would be like the ray hitting the triangle directly on the edge, which can't really happen, since triangles have zero thickness. We could think of the ray hitting just one side of the triangle, but then are we really colliding with a triangle at all? This gives us insight into the shape we're after. What shape is one side of a triangle (or any polygon for that matter)? A line segment.</p> <p>If we back up to why we are using triangles in the first place, this makes a lot of sense. As mentioned previously, we can think of our mesh of triangles as approximating some smooth 3D surface. This discretized the problem into finite objects that are easier to understand and work with. In 2D, we want an equivalent discretization of a smooth 2D surface (i.e. a curve) into finite simpler to understand 2D shapes. How can we approximate a curve with a finite set of simpler 2D shapes? We can use a set of mesh of line segments.</p> <p></p> \"Approximate arc length.svg\" by PlatypeanArchcow is licensed under CC0 1.0 via Wikimedia Commons","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#defining-the-problem","title":"Defining the Problem","text":"<p>Finally, we're ready to start tackling the 2D analog of the problem. From a high level our problem is simple: given a ray and a line segment, where does the ray hit a triangle? But before we can solve this, we need to define things more clearly:</p> <ul> <li>What is a ray?</li> <li>How do we model it?</li> <li>How do we model a line segment?</li> <li>What does it mean for a ray to hit a line segment?</li> <li>Can a ray hit the same line segment more than once?</li> <li>How do we know if it misses?</li> </ul>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#what-is-a-ray","title":"What is a Ray?","text":"<p>A ray is simply a portion of a line that is bounded at one end. There could be many ways to model a ray mathematically, but to arrive at a model applicable to our problem, we need to consider what it is we know and what it is we are looking for. Generally, we will know where the ray originates\u2014we call this the ray origin, denoted by \\(E\\) for eye (in traditional ray tracing rays originate at the eye/camera instead of the light source for reasons outside the scope of this post)\u2014and we will also know where the ray is pointing, i.e., the direction \\(\\mathbf{\\hat{d}}\\). We want an expression for an arbitrary point \\(R\\) on the ray, since our problem is to find the point at which the ray hits the line segment. To get to any point on the ray, we just have to start at \\(E\\) and travel in the direction \\(\\mathbf{\\hat{d}}\\) for some distance \\(t\\). This has the side effect that every point on our ray is wholly determined by our choice of \\(t\\). We can combine this information with our relationships from Discriminating Between Points &amp; Vectors to derive a function for any point on the ray in terms of distance from the ray origin:</p> \\[R(t) = E + t\\mathbf{\\hat{d}}, \\quad t \\geq 0\\] <p>We can summarize this equation succinctly: \\(R\\) is the point \\(t\\) units from \\(E\\) in the direction \\(\\mathbf{\\hat{d}}\\). Does this sound familiar? It should. We've already seen almost this exact same equation before, just with different symbols. The key difference here is that \\(t\\) has been restricted so that all of the points of the ray lie to one side of \\(E\\). We didn't need to state this earlier, because we were explicitly referring to the vector magnitude, which is always non-negative. However, in this case, we have an arbitrary scalar, so we need to explicitly define its range.</p> <p>One final note about our ray definition: it is possible to use non-unit direction vectors, but this has the problem that there are an infinite number of point\u2013vector pairs that define the same ray. Whereas, every point\u2013unit vector pair uniquely defines a ray. Additionally, using unit direction vectors normalizes \\(t\\) to always represent a unit distance, no matter the ray. This information can be handy in other contexts. In general, sticking to unit direction vectors for rays simplifies conceptualization and calculation, not just with regards to MT.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#what-is-a-line-segment","title":"What is a Line Segment?","text":"<p>I think most people are familiar with what a line segment is, but I want to draw a particular definition: a line segment is a portion of a line bounded at both ends. Notice how this mirrors our ray definition. Also like with the ray, we're after a particular model of a line segment amenable to our problem. Starting with what we know, a line segment \\(AB\\) is usually defined by its two end points, \\(A\\) and \\(B\\). We want to be able to find an arbitrary point \\(S\\), somewhere on the straight-line path between them. Luckily, there is a very well-established way to find an arbitrary point between two other points: linear interpolation. We can use it to form a function for an arbitrary point \\(S\\), \\(u\\) percent of the way from \\(A\\) to \\(B\\), in terms of \\(u\\):</p> \\[S(u) = (1 - u)A + uB, \\quad 0 \\leq u \\leq 1\\] An alternative derivation <p>We could have approached this in a similar manner to the ray:</p> \\[S(s) = A + s\\frac{B - A}{||B - A||}, \\quad 0 \\leq s \\leq ||B - A||\\] <p>This is pretty messy though, and has the disadvantage of making the parameter bounds dependent on the choice of \\(A\\) and \\(B\\). However, with a simple change of variable, we can get the same model as with our linear interpolation approach. Let \\(u = \\frac{s}{||B - A||} \\implies s = u||B - A||\\).</p> \\[\\begin{align*}     S(u) &amp;= A + u||B - A||\\frac{B - A}{||B - A||}, &amp; 0 \\leq u||B - A|| \\leq ||B - A|| \\\\     &amp;= A + u(B - A), &amp; 0 \\leq u \\leq 1 \\\\     &amp;= A + uB - uA, &amp; 0 \\leq u \\leq 1 \\\\     &amp;= (1 - u)A + uB, &amp; 0 \\leq u \\leq 1 \\end{align*}\\] <p>This is pretty neat, so I thought I'd include it, but it's not as practical as our other approach.</p> <p>As much as I'd love to go into the intuition behind linear interpolation, I can't explain everything, so we'll just take on faith that it works.</p> <p>As with the ray, it is pretty interesting (and convenient) that the points on the line segment are wholly determined by our choice of \\(u\\). This fact will become important later.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#what-does-it-mean-for-a-ray-to-hit-something","title":"What Does it Mean for a Ray to Hit Something?","text":"<p>The key to understanding where a ray hits a line segment (or any object for that matter) is to realize that this point has to be both a point on the ray and a point on the line segment. In other words, the points must be equal:</p> \\[R(t) = S(u)\\] <p>This means that we simply need to find the choice of \\(t\\) and \\(u\\) that make the above equation hold. This begs the question, is there only a single \\(t\\)\u2013\\(u\\) pair that satisfies this problem?</p> <p>Recall that both a ray and a segment are portions of a line. As such, each sits on a particular line. Unless these lines are parallel, they cross over each other exactly once at a single point. Since our ray and line segment represent only a subset of the points of each line, we can conclude that all of the points at which they intersect must be a subset of the points at which the lines intersect. That is, at most one.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#how-do-we-know-if-a-ray-misses-a-line-segment","title":"How Do We Know If a Ray Misses a Line Segment?","text":"<p>The previous section already all but spelled out our first miss condition: if the ray and line segment are parallel.</p> <p>Also stated previously, if they aren't parallel, the lines on which they lie on will always intersect at a single \"candidate\" point. As mentioned above, this candidate point still needs to lie within the ranges of our point functions. This gives two possible miss conditions for our candidate point:</p> <ol> <li>The candidate is not in the range of \\(R\\)\u2014the candidate point is a negative distance \\(t\\) from (i.e., behind) \\(E\\) relative to direction \\(\\mathbf{\\hat{d}}\\).</li> <li>The candidate is not in the range of \\(S\\)\u2014the candidate is in front (i.e., in the path) of the ray, but it goes past one of the ends of the segment. This happens when either \\(u &lt; 0\\) and passing the \\(A\\) end of the segment, or \\(u &gt; 1\\) and passes the \\(B\\) end of the segment.</li> </ol> <p>Note: these two conditions can happen simultaneously, but usually, you'll check one first\u2014probably \\(t\\)\u2014and exit early if a miss is detected.</p> <p>Try moving the points and direction around and see if you can produce the three miss conditions we've mentioned:</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#a-refined-problem-statement","title":"A Refined Problem Statement","text":"<p>With all of that out of the way, we can refine our problem to get to what we really want: given a ray defined by a point \\(E\\) and a direction \\(\\mathbf{\\hat{d}}\\), and a line segment \\(AB\\) defined by points \\(A\\) and \\(B\\), is there a choice of parameters \\(t\\) and \\(u\\) within their respective domains, such that \\(R(t) = S(u)\\).</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#the-solution","title":"The Solution","text":"<p>As stated in the problem, we're looking for \\(R(t) = S(u)\\), so let's start there:</p> \\[\\begin{align*}     R(t) &amp;= S(u) \\\\     E + t\\mathbf{\\hat{d}} &amp;= A + u(B - A) \\\\ \\end{align*}\\] <p>Now, we'll rearrange to get our terms containing unknowns alone on one side of the equation:</p> \\[E - A = t(-\\mathbf{\\hat{d}}) + u(B - A)\\] <p>Note</p> <p>I've brought the negative sign inside parentheses with the ray direction. This is to emphasize that the distance is non-negative and that this term is pointing in the opposite direction as the ray.</p> <p>Let's stop to think about what this equation means. We can think of each side of the equation representing a different path. By setting these paths equal, we're not saying they travel the same distance, but that they have the same displacement. In other words, if a traveler starts down either path from the same location, they will arrive at the same destination. Notice that the LHS explicitly tells us that if we start at \\(A\\), we'll arrive at \\(E\\). That means that if the path defined by the RHS starts at \\(A\\), it too will arrive at \\(E\\). This makes conceptual sense. Imagine we already have the exact \\(t\\) and \\(u\\) of our solution. If we start at \\(A\\) and travel \\(u\\) percent of the way to \\(B\\), we'll be at the intersection point. If we then travel from the intersection point \\(t\\) units in the opposite direction as the ray, we'll arrive back at \\(E\\), the ray origin.</p> <p>Try dragging the slider to the right to help visualize traversing these paths:</p> <p>Note</p> <p>I've removed the axes to emphasize that we are just interested in the vectors. The points are included just to show how these vectors relate to the problem.</p> <p>Now the question becomes, how do we solve for \\(t\\) and \\(u\\)? Decomposing the vectors into their components reveals that what we are really dealing with a system of equations:</p> \\[\\begin{gather*}     E_x - A_x = t(-\\hat{d}_x) + u(B_x - A_x) \\\\     E_y - A_y = t(-\\hat{d}_y) + u(B_y - A_y) \\end{gather*}\\] <p>Many of you have encountered such systems of equations in highschool, even if your curriculum didn't cover linear algebra. Those techniques would work here, but we want to avoid algebraic mechanics and look at things more conceptually, so we'll opt for the more revealing perspective that linear algebra provides. Linear algebra gives us a new tool, the matrix, which together with matrix\u2013vector multiplication, gives a way to extract the coefficients from a linear combination of vectors:</p> \\[\\begin{align*}     E - A &amp;= \\begin{bmatrix}         | &amp; | \\\\         -\\mathbf{\\hat{d}} &amp; (B - A) \\\\         | &amp; | \\\\     \\end{bmatrix}\\begin{bmatrix}         t \\\\         u     \\end{bmatrix} \\\\     &amp;= \\begin{bmatrix}         -\\hat{d}_x &amp; B_x - A_x \\\\         -\\hat{d}_y &amp; B_y - A_y \\\\     \\end{bmatrix}\\begin{bmatrix}         t \\\\         u     \\end{bmatrix} \\\\     &amp;= \\mathbf{M}\\begin{bmatrix}         t \\\\         u     \\end{bmatrix} \\end{align*}\\] <p>We can think of multiplying a vector on the left by the matrix \\(\\mathbf{M}\\) as a transforming it from solution space (all possible \\(t\\)\u2013\\(u\\) pairs) to a vector in physical space. The convention for denoting this translation between spaces is to define the column vectors of the matrix as a set called a basis:</p> \\[\\beta = \\{-\\mathbf{\\hat{d}}, B - A\\}\\] <p>We can then denote \\(\\mathbf{M}\\mathbf{u}\\) as \\([\\mathbf{u}]_\\beta\\). This is called a change of basis. It may not be obvious at first, but the vector \\((t, u)\\) is the coordinates of the vector \\(E - A\\) in solution space, i.e., \\((t, u) = [E - A]_\\beta\\).</p> <p>So, we have a way to convert points in solution space into points in physical space. This would be great if we already had a solution, but we want to find the solution. How can we do this? Imagine a function \\(f\\):</p> \\[f(\\mathbf{u}) = \\mathbf{M}\\mathbf{u}\\] <p>If we could find the inverse of this function, then we should be able to move from physical space to solution space. This would let us use what we know about the objects in physical space to find the solution to our problem:</p> \\[\\begin{bmatrix}     t \\\\     u \\end{bmatrix} = f^{-1}(E - A)\\] <p>Luckily, matrices have an analogous idea: the matrix inverse:</p> \\[\\begin{bmatrix}     t \\\\     u \\end{bmatrix} = \\mathbf{M}^{-1}(E - A)\\] <p>You can visualize this transformation in either direction by dragging the slider back and forth:</p> <p>Note</p> <p>I've drawn only a few grid lines to improve performance. I've also played kind of fast and loose with the labelling, but this is meant to just give a sense for what is happening rather than a rigorous representation.</p> <p>We're not going to worry about the mechanics of finding a matrix inverse. There is a plethora of resources on the various methods online. However, it is important to note that an inverse isn't guaranteed. There some conditions (most of which turn out to be equivalent) that have to be met for an inverse to exist. One of the conditions is that the matrix is square. This is a huge topic and we aren't going to go into it here, but it is related to why the 2D analog to a triangle is a segment. We are working in 2D, so the matrix has two rows. Thus, we need two columns, i.e., two basis vectors. Our basis vectors are defined by our ray, and the object it intersects (this will come back later in the 3D version). For this condition to be met, the problem needs to be set up correctly from the beginning, so doesn't actually have much to do with solving the problem.</p> <p>Another condition for invertibility is that the column vectors be linearly independent. For only two vectors, this is the same as saying they are not parallel. Recall this was one of our miss conditions. This gives us our first way to check for a miss: if we can't find an inverse, the ray misses.</p> <p>Our inverse, however, has no sense of our function domains, and as long as our direction is well-defined, \\(A \\neq B\\), and \\(\\mathbf{\\hat{d}}\\) is not parallel to \\(B - A\\), our matrix should have an inverse. This inverse matrix gives will translate \\(E - A\\) into the parameters of the candidate point we talked about earlier. Then, all that is left is checking whether or not \\(t\\) and \\(u\\) are within their respective ranges:</p> \\[t \\geq 0, 0 \\leq u \\leq 1\\] <p>That's it! We've solve the 2D ray\u2013line segment intersection problem. To summarize:</p> <ol> <li>Create the matrix \\(\\mathbf{M}\\) from what is known about the ray and line segment</li> <li>Attempt to find the matrix inverse. If an inverse doesn't exist, exit with a miss</li> <li>Compute \\(\\mathbf{M}^{-1}(E - A)\\):<ul> <li>If \\(t &lt; 0\\), exit with a miss</li> <li>If \\(u &lt; 0\\), exit with a miss</li> <li>If \\(u &gt; 1\\), exit with a miss</li> </ul> </li> <li>Return \\(t\\) and \\(u\\)</li> </ol> <p>Finally, a visualization of what the solution looks like:</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#translating-back-to-3d","title":"Translating Back to 3D","text":"<p>Although we started thinking about the problem of triangles in 3D and arrived at a 2D analog involving line segments, translating back to 3D may not naturally lead us back to triangles\u2014at least not right away. Let's think about how to most naturally extend the problem we just solved to 3D before moving on to triangles.</p> Is 3D ray-line segment intersection possible? <p>It turns out that this doesn't work, at least not using the methods in this article. I will leave it as homework to try and figure out why. I'll show you how I think of it in a follow-up post.</p> <p>Recall our line segment equation:</p> \\[S(u) = A + u(B - A), \\quad 0 \\leq u \\leq 1\\] <p>What is the most natural way to extend this line segment to 3D? To answer this, let's change our perspective on what your line segment is. A line segment lives on a line, as we've already seen. Lines in 2D space can be thought of as 1D subspaces. When a subspace is one dimension lower than surrounding space, it is called a hyperplane. We can then think of a line segment as a hyperplane in 2D that is bounded along its only axis.</p> <p>In this sense, the natural extension of a line segment to 3D would be a hyperplane in 3D (i.e., a plane) that is bounded along both its axes. Think back to our discussion of basis vectors. We have a single basis vector that spans all of 1D space, so to span our plane, we need another, linearly independent basis vector. We could add any vector and a scaling parameter to accomplish this, but since we are working toward a triangle, it makes sense to add a third point \\(C\\) and create our second basis vector relative to it: \\(C - A\\). This gives the following function for our new shape:</p> \\[P(u, v) = A + u(B - A) + v(C - A), \\quad 0 \\leq u, v \\leq 1\\] <p>What is this shape? Let's start following a path around the outside and see if we can figure it out. \\(P(0, 0) = A\\). This will be our starting point. As we increase \\(u\\) from 0 to 1, we travel along the path \\(B - A\\) towards \\(B\\). \\(P(1, 0) = B\\). From here, as we increase \\(v\\) from 0 to 1, we travel along the path \\(C - A\\) toward a new point. Let's call it \\(D\\). Now, we start decreasing \\(u\\) again. This causes us to move toward \\(C\\) along the path \\(A - B\\). Recall, this is just the opposite direction as \\(B - A\\), so is parallel. We arrive at \\(C\\), and if we complete the trip by decreasing \\(v\\) back to 0, we'll travel along \\(A - C\\) (parallel to \\(C - A\\)) until we arrive back at \\(A\\). So, we have a shape with four points and four sides where opposite sides are parallel. It's a parallelogram!</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#parallelogram-mollertrumbore","title":"Parallelogram M\u00f6ller\u2013Trumbore","text":"<p>Before moving on to triangles, we're going to solve the parallelogram version of MT first. I think it is easier to understand and the extension to triangles is very simple. Parallelogram MT is almost identical to 2D MT, so we're not going to dwell on the details:</p> \\[\\begin{align*}     R(t) &amp;= T(u, v) \\\\     E + t\\mathbf{\\hat{d}} &amp;= A + u(B - A) + v(C - A) \\\\     E - A &amp;= t(-\\mathbf{\\hat{d}}) + u(B - A) + v(C - A) \\\\     &amp;= \\begin{bmatrix}         | &amp; | &amp; | \\\\         -\\mathbf{\\hat{d}} &amp; (B - A) &amp; (C - A) \\\\         | &amp; | &amp; |     \\end{bmatrix}\\begin{bmatrix}         t \\\\         u \\\\         v     \\end{bmatrix} \\\\     &amp;= \\begin{bmatrix}         -\\hat{d}_x &amp; B_x - A_x &amp; C_x - A_x \\\\         -\\hat{d}_y &amp; B_y - A_y &amp; C_y - A_y \\\\         -\\hat{d}_z &amp; B_z - A_z &amp; C_z - A_z     \\end{bmatrix}\\begin{bmatrix}         t \\\\         u \\\\         v     \\end{bmatrix} \\\\     &amp;= \\mathbf{M}\\begin{bmatrix}         t \\\\         u \\\\         v     \\end{bmatrix} \\\\     \\begin{bmatrix}         t \\\\         u \\\\         v     \\end{bmatrix} &amp;= \\mathbf{M}^{-1}(E - A) \\\\ \\end{align*}\\] <p>It is then exactly like the 2D, but we have one additional check to make:</p> \\[0 \\leq v \\leq 1\\] <p>Conceptually, everything works very much the same:</p> <ul> <li>If the ray and parallelogram are parallel, this is an obvious miss.</li> <li>If they are not, then the line that the ray lies on intersects the plane that the parallelogram lies on in exactly one point. This is a candidate point for an intersection.</li> <li>If the ray is pointing away from the parallelogram it misses. This corresponds to \\(t\\) being negative.</li> <li>If the ray is pointing towards the plane of the parallelogram, but \\(u\\) or \\(v\\) are out of ranges, the ray has missed, but now there are four edges it can pass by instead of two ends.</li> </ul>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#extending-to-triangles","title":"Extending to Triangles","text":"<p>Extending to triangles is very simple, but requires some explanation. Imagine we create a new function \\(\\tilde{T}\\) based on our parallelogram, but with \\(u\\) fixed at \\(1 - v\\):</p> \\[\\tilde{T}(v) = A + (1 - v)(B - A) + v(C - A), \\quad 0 \\leq v \\leq 1\\] <p>Notice this looks a lot like linear interpolation. Imagine starting \\(\\tilde{T}(0) = B\\). As we increase \\(v\\) from 0 to 1, our \\(B - A\\) vector is scaled down by the same amount \\(C - A\\) is scaled up, so \\(\\tilde{T}\\) travels from \\(B\\) to \\(C\\) in a straight line. This line creates a triangle with \\(AB\\) and \\(AC\\). Now, we just need to incorporate the interior points.</p> <p>Let's reintroduce \\(u\\), but keep its relationship to \\(v\\) in the form of a constraint:</p> \\[\\tilde{T}(u, v) = A + u(B - A) + v(C - A), \\quad 0 \\leq u, v \\leq 1, u + v = 1\\] <p>As long as our \\(u + v = 1\\) condition holds, all points of \\(\\tilde{T}\\) will be along the diagonal from \\(B\\) to \\(C\\). Now, consider what happens if from any point along this line, we reduce \\(u\\) or \\(v\\). The point gets closer to \\(A\\). Conversely, if we increase \\(u\\) or \\(v\\), the point gets closer to \\(D\\). This tells use that we only have to make sure the sum of \\(u\\) and \\(v\\) never gets bigger than 1:</p> \\[T(u, v) = A + u(B - A) + v(C - A), \\quad 0 \\leq u, v \\leq 1, u + v \\leq 1\\] <p>And we have a formula for any point on or inside a triangle that mirrors our parallelogram. In fact, it only differs by a single constraint.</p> <p>Try moving the point around and see what happens and when certain conditions fail. See if you can notice an interesting pattern:</p> <p>Note</p> <p>More commonly, we define \\(w = 1 - u - v\\), and check \\(w \\geq 0\\). Why? \\(u\\), \\(v\\), and \\(w\\) define what are called barycentric coordinates. \\(u\\), \\(v\\), and \\(w\\), tell us how close we are to \\(B\\), \\(C\\), and \\(A\\), respectively. I'd like to make a whole post on barycentric coordinates at some point.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#summary","title":"Summary","text":"<p>This was a long, meandering approach to learning this algorithm, so I'd like to take a minute to summarize the full 3D triangle MT algorithm:</p> <ol> <li>Construct the matrix \\(\\mathbf{M}\\) with column vectors \\(-\\mathbf{\\hat{d}}\\), \\(B - A\\), and \\(C - A\\).</li> <li>Attempt to find the matrix inverse, \\(\\mathbf{M}^{-1}\\). If an inverse doesn't exist, exit with a miss.</li> <li>Compute \\(\\mathbf{M}^{-1}(E - A)\\). If any of the following conditions are met, exit with a miss:<ul> <li>\\(t &lt; 0\\)</li> <li>\\(u &lt; 0\\)</li> <li>\\(u &gt; 1\\)</li> <li>\\(v &lt; 0\\)</li> <li>\\(v &gt; 1\\)</li> <li>\\(u + v &gt; 1\\)</li> </ul> </li> <li>Return \\(t\\) and \\(u\\)</li> </ol>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/#a-basic-python-implementation","title":"A Basic Python Implementation","text":"<p>This implementation uses numpy</p> <p>You will need to make sure you have numpy installed for this to work</p> <p>The most common way to handle intersections in ray tracing code is to have the <code>intersect</code> function return the value of \\(t\\) associated with the intersection. To recover the point, just use the <code>at</code> function, which returns a point on the ray.</p> <p>Since \\(t\\) must be non-negative, a common way to encode misses is as a -1. However, I prefer to raise an exception, because I find it makes things a lot clearer when the return value of a function only has one meaning. The <code>intersect</code> function returns the \\(t\\) value of the intersection. Since -1 is not a valid \\(t\\) value, it is confusing to return this. Instead, since there is no valid \\(t\\) value for a miss, we raise an exception. This is somewhat analogous to a division by zero error.</p> mt.py<pre><code>import sys\n\nimport numpy as np\n\n\nclass DoNotIntersectException(Exception):\n    ...\n\n\nclass Triangle:\n    def __init__(self, A, B, C) -&gt; None:\n        self.A = np.array(A)\n        self.B = np.array(B)\n        self.C = np.array(C)\n\n\nclass Ray:\n    def __init__(self, origin, direction) -&gt; None:\n        distance = np.linalg.norm(direction)\n\n        # Check direction makes sense\n        if distance == 0:\n            raise ValueError(\"Ambiguous direction\")\n\n        # Assure unit length\n        direction /= np.linalg.norm(direction)\n\n        self.origin = np.array(origin)\n        self.direction = np.array(direction)\n\n    def intersect(self, object: Triangle) -&gt; float:\n\"\"\"Given an object, returns the distance from the ray origin to the\n        point of intersection with the object.\"\"\"\n\n        if isinstance(object, Triangle):\n            # Create matrix transform from solutions space to physical space\n            soln_to_phys = np.column_stack((-self.direction,\n                                            object.B - object.A,\n                                            object.C - object.A))\n            # Attempt to invert\n            try:\n                phys_to_soln = np.linalg.inv(soln_to_phys)\n\n            # Coplanar direction and triangle\n            except np.linalg.LinAlgError:\n                raise DoNotIntersectException()\n\n            # Transform vector from A to ray origin into solution\n            t, u, v = phys_to_soln@(self.origin - object.A)\n            w = 1 - u - v\n\n            # Check domains\n            if t &gt;= 0 and 0 &lt;= u &lt;= 1 and 0 &lt;= v &lt;= 1 and w &lt;= 1:\n                return t\n\n        raise DoNotIntersectException()\n\n    def at(self, t: float) -&gt; np.ndarray:\n\"\"\"Given a distance, returns a point at that distance away from the\n        origin along the ray.\"\"\"\n\n        return self.origin + t*self.direction\n\n\ndef main():\n    values = tuple(map(float, sys.argv[1:]))\n\n    ray = Ray(origin=values[:3], direction=values[3:6])\n    triangle = Triangle(values[6:9], values[9:12], values[12:15])\n\n    print(ray.intersect(triangle))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>I have included a very simple CLI to manually test the implementation.</p> <p>Usage:</p> <pre><code>python mt.py ex ey ez dx dy dz ax ay az bx by bz cx cy cz\n</code></pre> <p>Example:</p> <pre><code>python mt.py 1 1 1 1 1 2 1 1 2 3 2 2 2 3 3\n</code></pre> <p>This should return <code>1.4696938456699067</code>.</p>","tags":["Linear Algebra","Computer Graphics","SoME","SoME3"]},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#computer-graphics","title":"Computer Graphics","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> <li>Splines 1: A Spline-Tingling Idea</li> </ul>"},{"location":"tags/#linear-algebra","title":"Linear Algebra","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> <li>Splines 1: A Spline-Tingling Idea</li> </ul>"},{"location":"tags/#some","title":"SoME","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> </ul>"},{"location":"tags/#some3","title":"SoME3","text":"<ul> <li>M\u00f6ller\u2013Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</li> </ul>"}]}