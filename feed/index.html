<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>Blog Base Two</title>
    <description>A Math and Computer Science Blog</description>
    <link>https://trslater.ca/blog-base-two/</link>
    <atom:link href="https://trslater.ca/blog-base-two/feed/"
               rel="self" type="application/rss+xml" />

    
    <item>
        <title>Improved Blogging Experience</title>
        <description><![CDATA[<h1 id="improved-blogging-experience">Improved Blogging Experience</h1>
<p><a href="https://squidfunk.github.io/mkdocs-material">MkDocs Material</a> (the amazing MkDocs theme that powers this site) has hit their $12,000 goal, which means they have made their blogging platform available to non-insiders! It is still in beta, but I decided to go for it anyway, because I really wanted my blog to feel more like a real blog.</p>
<!-- more -->

<p>There is one wrinkle: it is not compatible with the Jupyter MkDocs plugin I was using, so for now, my old posts (which were Jupyter notebooks) have been taken down. I plan to convert them to Markdown at some point, but for now, the blog just has this one post.</p>]]></description>
        <link>https://trslater.ca/blog-base-two/2023/07/13/improved-blogging-experience/</link>
        <guid>https://trslater.ca/blog-base-two/2023/07/13/improved-blogging-experience/</guid>
        <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>
    </item>
    
    <item>
        <title>Möller–Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</title>
        <description><![CDATA[<h1 id="mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle">Möller–Trumbore: Photorealistic Lighting Starts With a Ray and a Triangle</h1>
<figure>
<p><a class="glightbox" href="../../../../assets/images/moller-trumbore/path-tracing-example.jpg" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="An image rendered using path tracing, demonstrating notable features of the technique" src="../../../../assets/images/moller-trumbore/path-tracing-example.jpg" /></a></p>
<figcaption>"<a href="https://commons.wikimedia.org/wiki/File:Path_tracing_001.png">Path tracing 001.png</a>" by Qutorial is licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a></figcaption>
</figure>
<p>Have you ever wondered how computers produce photorealistic lighting: shading, shadows, reflections, depth of field, etc.? Most commonly, this is done via <strong>ray tracing</strong> or one of its descendants (e.g., path tracing or photon mapping). The basic idea is to mimic the way rays of light travel around a scene and what colour the ray is when it reaches the eye/camera. There are many ways light rays interact within a scene, but they almost all require knowing <em>where a ray hits an object</em>. From this point it can bounce off, refract through, or be used to simulate the effect of many rays spraying out in all directions. This article will focus ray collisions with the most general of objects: the humble triangle. We will start with an intuitive understanding of the problem and work our way up to an elegant and efficient solution known as the <strong>Möller–Trumbore</strong> algorithm.</p>
<!-- more -->

<h2 id="requisite-knowledge">Requisite Knowledge</h2>
<p>This article should be well understood by anyone with a highschool math education. An understanding of vectors and vector operations (addition, subtraction, dot product, etc.) is probably required as well. There is some linear algebra, but I explain the notation and operations at a high level, and we don't actually perform any computations, so previous knowledge of linear algebra probably isn't necessary, though an understanding of very basic concepts couldn't hurt.</p>
<h2 id="discriminating-between-points-vectors">Discriminating Between Points &amp; Vectors</h2>
<p>Something that is not commonly taught unless you are specifically learning about graphics is to consider points and vectors as distinct from one another. Generally, any coordinate can be considered a point or vector interchangeably. Mathematically, the distinction isn't strictly necessary, but I find it useful, especially when modelling physical space—commonly the case in computer graphics. I also find that there is a lack of consistent conventions surrounding this distinction, so I think it is worth providing a primer on how these concepts and notation will be used in this article.</p>
<h3 id="notation">Notation</h3>
<p>The notation I use can be summarize in the following table:</p>
<table>
<thead>
<tr>
<th>Quantity</th>
<th align="center">Bold</th>
<th align="center">Italic</th>
<th align="center">Uppercase</th>
<th align="center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scalar</td>
<td align="center"></td>
<td align="center">X</td>
<td align="center"></td>
<td align="center"><span class="arithmatex">\(t\)</span></td>
</tr>
<tr>
<td>Point</td>
<td align="center"></td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center"><span class="arithmatex">\(P\)</span></td>
</tr>
<tr>
<td>Vector</td>
<td align="center">X</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span class="arithmatex">\(\mathbf{u}\)</span></td>
</tr>
<tr>
<td>Unit Vector</td>
<td align="center">X</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span class="arithmatex">\(\mathbf{\hat{u}}\)</span></td>
</tr>
<tr>
<td>Matrix</td>
<td align="center">X</td>
<td align="center"></td>
<td align="center">X</td>
<td align="center"><span class="arithmatex">\(\mathbf{A}\)</span></td>
</tr>
</tbody>
</table>
<h3 id="definitions-operations">Definitions &amp; Operations</h3>
<p>A <strong>vector</strong> is a <em>direction</em> and <em>distance</em>. More generally, the distance is referred to as "magnitude," but because it is more intuitive when modelling physical spaces, I'll generally refer to the magnitude of a vector as its "distance." Vectors can be added, subtracted, and multiplied together (dot, cross, or matrix multiplication). Vectors can also be scaled by a real number, i.e., a scalar.</p>
<p>A <strong>point</strong> is a <em>location</em> in space. It has no sense of direction or distance. The only operation that makes sense between two points is subtraction (think through the other operations and see if you can see why they don't make sense). This results in a vector that represents the distance between two points and the direction from one to the other. This simple relationship encapsulates all the ways points and vectors can be combined:</p>
<div class="arithmatex">\[\begin{equation}
    B - A = \mathbf{u}
\end{equation}\]</div>
<p>In this equation, the direction points from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>. What about going from <span class="arithmatex">\(B\)</span> to <span class="arithmatex">\(A\)</span>? Consider the following equations:</p>
<div class="arithmatex">\[\begin{gather*}
    A - B = -\mathbf{u} \\
    ||A - B|| = ||B - A||
\end{gather*}\]</div>
<p>Swapping the minuend and the subtrahend results in a vector pointing in the opposite direction. Note: this is notated with a negative sign (this can be thought of as the vector being scaled by -1). However, the distance between two points is the same whether pointing from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span> or <span class="arithmatex">\(B\)</span> to <span class="arithmatex">\(A\)</span>. This should all make fairly intuitive sense. Bob has to run in the opposite direction to reach Alice that Alice would need to run to reach Bob, but their distance from one another is the same from either vantage point.</p>
<p>Another key relationship to understand is the following:</p>
<div class="arithmatex">\[\mathbf{u} = ||\mathbf{u}||\mathbf{\hat{u}}\]</div>
<p>This encapsulates how a vector can be decomposed into distance and direction, a very useful tool to have. Rearranging this also shows us how to compute a unit vector:</p>
<div class="arithmatex">\[\mathbf{\hat{u}} = \frac{\mathbf{u}}{||\mathbf{u}||}\]</div>
<details class="question">
<summary>Can you divide by a vector?</summary>
<p>It is interesting to think about the following:</p>
<div class="arithmatex">\[||\mathbf{u}|| = \frac{\mathbf{u}}{\mathbf{\hat{u}}}\]</div>
<p>Generally, we don't have a notion of dividing by a vector, but here it seems to make sense. I'll leave it to you to ponder.</p>
</details>
<p>To me, these two relationships are some of the most useful to keep in mind when working with mathematical models of physical space.</p>
<h3 id="visualizing-vectors">Visualizing Vectors</h3>
<p>Vectors are often depicted as arrows originating at the origin, but this is misleading. In reality, there isn't a good visual representation of a vector—at least in relation to other objects—because they have no location. An object needs to exist at a location for you to draw it. Thus, there are always two implicit points when drawing a vector: the origin and the destination. This relationship can be understood better by rearranging the point difference equation and combining it with the vector decomposition equation:</p>
<div class="arithmatex">\[B = A + ||\mathbf{u}||\mathbf{\hat{u}}\]</div>
<p>This equation reads, if we start at position <span class="arithmatex">\(A\)</span> and travel in direction <span class="arithmatex">\(\mathbf{\hat{u}}\)</span> for a distance of <span class="arithmatex">\(||\mathbf{u}||\)</span>, we will end up at position <span class="arithmatex">\(B\)</span>. In this sense, <span class="arithmatex">\(\mathbf{u}\)</span> can be thought of as the path such that if you follow it from <span class="arithmatex">\(A\)</span> you will arrive at <span class="arithmatex">\(B\)</span>. This may seem pedantic, but isn't that what math is all about? All kidding aside, it matters. For one thing, if we always think of a vector starting at the origin, it can be hard to make sense of vectors that represent things like forces that act on a particular location. Additionally, moving vectors around can give helpful insights to a problem.</p>
<h2 id="why-triangles">Why Triangles?</h2>
<p>Before we get started, a question might be popping out at you: why does a triangle represent a the most general case of an object in a 3D scene? Without getting into too much detail, any 3D surface can be approximated arbitrarily well using a mesh of triangles. Why not rectangles, pentagons, etc.? That is out of the scope of this article, but it has been found to greatly simplify storage and calculations of meshes. What is important for this article is that the vast majority of 3D objects are modelled as meshes of triangles. Therefore, knowing where a ray hits a single triangle is the same as knowing where a ray hits any arbitrary 3D surface—at least to a good approximation. To collect the data of ray collisions across any number of objects and rays is as simple as—glossing over some technicalities of course—iterating over the triangles in a scene for each ray.</p>
<figure>
<p><a class="glightbox" href="../../../../assets/images/moller-trumbore/dolphin-triangle-mesh.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="An image rendered using path tracing, demonstrating notable features of the technique" src="../../../../assets/images/moller-trumbore/dolphin-triangle-mesh.png" style="display: block; margin: 0 auto;" width="300," /></a></p>
<figcaption>"<a href="https://en.wikipedia.org/wiki/File:Dolphin_triangle_mesh.png">Dolphin triangle mesh.png</a>" by <a href="https://en.wikipedia.org/wiki/User:Chrschn">Chrschn</a> is licensed under public domain</figcaption>
</figure>
<h2 id="2d-mollertrumbore">2D Möller–Trumbore</h2>
<p>With all of the preamble out of the way, it is time to start tackling our problem. However, as is usually the case with any new math problem, solving a simpler version of problem first is usually helpful in finding the final solution. When it comes to 3D graphics problems, this often means solving its 2D analog. 2D environments are simpler, easier to understand, and require a lot less algebra and computing power when modelling with code. Perhaps most importantly though, visual representations are almost always easier to parse. It may seem like extra work, but it often turns out to be less work to start in 2D and translate the solution to 3D than to start in 3D.</p>
<h3 id="translating-mollertrumbore-to-2d">Translating Möller–Trumbore to 2D</h3>
<p>At first, it might be tempting to think we can just shoot a 2D ray at a triangle lying in the 2D plane. After all, isn't a triangle already a 2D shape? It is, but we are not simply looking to find an analogous shape, but an analogous problem. For one, in 2D space, the triangle and ray always live on the same plane which is vanishingly unlikely in 3D. Conceptually, it would be like the ray hitting the triangle directly on the edge, which can't really happen, since triangles have zero thickness. We could think of the ray hitting just one side of the triangle, but then are we really colliding with a triangle at all? This gives us insight into the shape we're after. What shape is one side of a triangle (or any polygon for that matter)? A <em>line segment</em>.</p>
<p>If we back up to why we are using triangles in the first place, this makes a lot of sense. As mentioned previously, we can think of our mesh of triangles as approximating some smooth 3D surface. This discretized the problem into finite objects that are easier to understand and work with. In 2D, we want an equivalent discretization of a smooth 2D surface (i.e. a curve) into finite simpler to understand 2D shapes. How can we approximate a curve with a finite set of simpler 2D shapes? We can use a set of mesh of line segments.</p>
<figure>
<p><a class="glightbox" href="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Approximate_arc_length.svg/360px-Approximate_arc_length.svg.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="An image rendered using path tracing, demonstrating notable features of the technique" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Approximate_arc_length.svg/360px-Approximate_arc_length.svg.png" style="display: block; margin: 0 auto;" width="300," /></a></p>
<figcaption>"<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Approximate_arc_length.svg/360px-Approximate_arc_length.svg.png">Approximate arc length.svg</a>" by PlatypeanArchcow is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/deed.en">CC0 1.0</a> via <a href="https://commons.wikimedia.org/wiki/Main_Page">Wikimedia Commons</a></figcaption>
</figure>
<h3 id="defining-the-problem">Defining the Problem</h3>
<p>Finally, we're ready to start tackling the 2D analog of the problem. From a high level our problem is simple: <em>given a ray and a line segment, where does the ray hit a triangle?</em> But before we can solve this, we need to define things more clearly:</p>
<ul>
<li>What is a ray?</li>
<li>How do we model it?</li>
<li>How do we model a line segment?</li>
<li>What does it mean for a ray to hit a line segment?</li>
<li>Can a ray hit the same line segment more than once?</li>
<li>How do we know if it misses?</li>
</ul>
<h4 id="what-is-a-ray">What is a Ray?</h4>
<p>A <strong>ray</strong> is simply <em>a portion of a line that is bounded at one end</em>. There could be many ways to model a ray mathematically, but to arrive at a model applicable to our problem, we need to consider what it is we know and what it is we are looking for. Generally, we will know where the ray originates—we call this the ray <strong>origin</strong>, denoted by <span class="arithmatex">\(E\)</span> for eye (in traditional ray tracing rays originate at the eye/camera instead of the light source for reasons outside the scope of this post)—and we will also know where the ray is pointing, i.e., the <strong>direction</strong> <span class="arithmatex">\(\mathbf{\hat{d}}\)</span>. We want an expression for an arbitrary point <span class="arithmatex">\(R\)</span> on the ray, since our problem is to find the <em>point</em> at which the ray hits the line segment. To get to any point on the ray, we just have to start at <span class="arithmatex">\(E\)</span> and travel in the direction <span class="arithmatex">\(\mathbf{\hat{d}}\)</span> for some distance <span class="arithmatex">\(t\)</span>. This has the side effect that every point on our ray is wholly determined by our choice of <span class="arithmatex">\(t\)</span>. We can combine this information with our relationships from <a href="#discriminating-between-points--vectors">Discriminating Between Points &amp; Vectors</a> to derive a function for any point on the ray in terms of distance from the ray origin:</p>
<div class="arithmatex">\[R(t) = E + t\mathbf{\hat{d}}, \quad t \geq 0\]</div>
<p>We can summarize this equation succinctly: <span class="arithmatex">\(R\)</span> is the point <span class="arithmatex">\(t\)</span> units from <span class="arithmatex">\(E\)</span> in the direction <span class="arithmatex">\(\mathbf{\hat{d}}\)</span>. Does this sound familiar? It should. We've already seen almost this exact same equation before, just with different symbols. The key difference here is that <span class="arithmatex">\(t\)</span> has been restricted so that all of the points of the ray lie to one side of <span class="arithmatex">\(E\)</span>. We didn't need to state this earlier, because we were explicitly referring to the vector <em>magnitude</em>, which is always non-negative. However, in this case, we have an arbitrary scalar, so we need to explicitly define its range.</p>
<iframe src="https://www.desmos.com/calculator/ye41347jsh?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<p>One final note about our ray definition: it is possible to use non-unit direction vectors, but this has the problem that there are an infinite number of point–vector pairs that define the same ray. Whereas, every point–unit vector pair <em>uniquely</em> defines a ray. Additionally, using unit direction vectors normalizes <span class="arithmatex">\(t\)</span> to always represent a unit distance, no matter the ray. This information can be handy in other contexts. In general, sticking to unit direction vectors for rays simplifies conceptualization and calculation, not just with regards to MT.</p>
<h4 id="what-is-a-line-segment">What is a Line Segment?</h4>
<p>I think most people are familiar with what a line segment is, but I want to draw a particular definition: <em>a line segment is a portion of a line bounded at both ends</em>. Notice how this mirrors our ray definition. Also like with the ray, we're after a particular model of a line segment amenable to our problem. Starting with what we know, a line segment <span class="arithmatex">\(AB\)</span> is usually defined by its two end points, <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>. We want to be able to find an arbitrary point <span class="arithmatex">\(S\)</span>, somewhere on the straight-line path between them. Luckily, there is a very well-established way to find an arbitrary point between two other points: <strong>linear interpolation</strong>. We can use it to form a function for an arbitrary point <span class="arithmatex">\(S\)</span>, <span class="arithmatex">\(u\)</span> percent of the way from <span class="arithmatex">\(A\)</span> to <span class="arithmatex">\(B\)</span>, in terms of <span class="arithmatex">\(u\)</span>:</p>
<div class="arithmatex">\[S(u) = (1 - u)A + uB, \quad 0 \leq u \leq 1\]</div>
<details class="note">
<summary>An alternative derivation</summary>
<p>We could have approached this in a similar manner to the ray:</p>
<div class="arithmatex">\[S(s) = A + s\frac{B - A}{||B - A||}, \quad 0 \leq s \leq ||B - A||\]</div>
<p>This is pretty messy though, and has the disadvantage of making the parameter bounds dependent on the choice of <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>. However, with a simple change of variable, we can get the same model as with our linear interpolation approach. Let <span class="arithmatex">\(u = \frac{s}{||B - A||} \implies s = u||B - A||\)</span>.</p>
<div class="arithmatex">\[\begin{align*}
    S(u) &amp;= A + u||B - A||\frac{B - A}{||B - A||}, &amp; 0 \leq u||B - A|| \leq ||B - A|| \\
    &amp;= A + u(B - A), &amp; 0 \leq u \leq 1 \\
    &amp;= A + uB - uA, &amp; 0 \leq u \leq 1 \\
    &amp;= (1 - u)A + uB, &amp; 0 \leq u \leq 1
\end{align*}\]</div>
<p>This is pretty neat, so I thought I'd include it, but it's not as practical as our other approach.</p>
</details>
<iframe src="https://www.desmos.com/calculator/kc6dwx7pan?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<p>As much as I'd love to go into the intuition behind linear interpolation, I can't explain everything, so we'll just take on faith that it works.</p>
<p>As with the ray, it is pretty interesting (and convenient) that the points on the line segment are wholly determined by our choice of <span class="arithmatex">\(u\)</span>. This fact will become important later.</p>
<h4 id="what-does-it-mean-for-a-ray-to-hit-something">What Does it Mean for a Ray to Hit Something?</h4>
<p>The key to understanding where a ray hits a line segment (or any object for that matter) is to realize that this point <em>has</em> to be both a point on the ray and a point on the line segment. In other words, the points must be equal:</p>
<div class="arithmatex">\[R(t) = S(u)\]</div>
<p>This means that we simply need to find the choice of <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span> that make the above equation hold. This begs the question, is there only a single <span class="arithmatex">\(t\)</span>–<span class="arithmatex">\(u\)</span> pair that satisfies this problem?</p>
<p>Recall that both a ray and a segment are portions of a line. As such, each sits on a particular line. Unless these lines are parallel, they cross over each other <em>exactly once</em> at a single point. Since our ray and line segment represent only a subset of the points of each line, we can conclude that all of the points at which they intersect must be a subset of the points at which the lines intersect. That is, <em>at most</em> one.</p>
<h4 id="how-do-we-know-if-a-ray-misses-a-line-segment">How Do We Know If a Ray Misses a Line Segment?</h4>
<p>The previous section already all but spelled out our first miss condition: <em>if the ray and line segment are parallel</em>.</p>
<p>Also stated previously, if they aren't parallel, the lines on which they lie on will <em>always</em> intersect at a single "candidate" point. As mentioned above, this candidate point still needs to lie within the ranges of our point functions. This gives two possible miss conditions for our candidate point:</p>
<ol>
<li><em>The candidate is not in the range of <span class="arithmatex">\(R\)</span></em>—the candidate point is a negative distance <span class="arithmatex">\(t\)</span> from (i.e., behind) <span class="arithmatex">\(E\)</span> relative to direction <span class="arithmatex">\(\mathbf{\hat{d}}\)</span>.</li>
<li><em>The candidate is not in the range of <span class="arithmatex">\(S\)</span></em>—the candidate is in front (i.e., in the path) of the ray, but it goes past one of the ends of the segment. This happens when either <span class="arithmatex">\(u &lt; 0\)</span> and passing the <span class="arithmatex">\(A\)</span> end of the segment, or <span class="arithmatex">\(u &gt; 1\)</span> and passes the <span class="arithmatex">\(B\)</span> end of the segment.</li>
</ol>
<p>Note: these two conditions can happen simultaneously, but usually, you'll check one first—probably <span class="arithmatex">\(t\)</span>—and exit early if a miss is detected.</p>
<p>Try moving the points and direction around and see if you can produce the three miss conditions we've mentioned:</p>
<iframe src="https://www.desmos.com/calculator/cbk4iqtnrk?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h4 id="a-refined-problem-statement">A Refined Problem Statement</h4>
<p>With all of that out of the way, we can refine our problem to get to what we really want: given a ray defined by a point <span class="arithmatex">\(E\)</span> and a direction <span class="arithmatex">\(\mathbf{\hat{d}}\)</span>, and a line segment <span class="arithmatex">\(AB\)</span> defined by points <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span>, is there a choice of parameters <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span> within their respective domains, such that <span class="arithmatex">\(R(t) = S(u)\)</span>.</p>
<h3 id="the-solution">The Solution</h3>
<p>As stated in the problem, we're looking for <span class="arithmatex">\(R(t) = S(u)\)</span>, so let's start there:</p>
<div class="arithmatex">\[\begin{align*}
    R(t) &amp;= S(u) \\
    E + t\mathbf{\hat{d}} &amp;= A + u(B - A) \\
\end{align*}\]</div>
<p>Now, we'll rearrange to get our terms containing unknowns alone on one side of the equation:</p>
<div class="arithmatex">\[E - A = t(-\mathbf{\hat{d}}) + u(B - A)\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I've brought the negative sign inside parentheses with the ray direction. This is to emphasize that the distance is non-negative and that this term is pointing in the opposite direction as the ray.</p>
</div>
<p>Let's stop to think about what this equation means. We can think of each side of the equation representing a different path. By setting these paths equal, we're not saying they travel the same distance, but that they have the same <em>displacement</em>. In other words, if a traveler starts down either path from the same location, they will arrive at the same destination. Notice that the LHS explicitly tells us that if we start at <span class="arithmatex">\(A\)</span>, we'll arrive at <span class="arithmatex">\(E\)</span>. That means that if the path defined by the RHS starts at <span class="arithmatex">\(A\)</span>, it too will arrive at <span class="arithmatex">\(E\)</span>. This makes conceptual sense. Imagine we already have the exact <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span> of our solution. If we start at <span class="arithmatex">\(A\)</span> and travel <span class="arithmatex">\(u\)</span> percent of the way to <span class="arithmatex">\(B\)</span>, we'll be at the intersection point. If we then travel <em>from</em> the intersection point <span class="arithmatex">\(t\)</span> units in the <em>opposite</em> direction as the ray, we'll arrive back at <span class="arithmatex">\(E\)</span>, the ray origin.</p>
<p>Try dragging the slider to the right to help visualize traversing these paths:</p>
<iframe src="https://www.desmos.com/calculator/n7jmqtboel?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I've removed the axes to emphasize that we are just interested in the vectors. The points are included just to show how these vectors relate to the problem.</p>
</div>
<p>Now the question becomes, how do we solve for <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span>? Decomposing the vectors into their components reveals that what we are really dealing with a system of equations:</p>
<div class="arithmatex">\[\begin{gather*}
    E_x - A_x = t(-\hat{d}_x) + u(B_x - A_x) \\
    E_y - A_y = t(-\hat{d}_y) + u(B_y - A_y)
\end{gather*}\]</div>
<p>Many of you have encountered such systems of equations in highschool, even if your curriculum didn't cover linear algebra. Those techniques would work here, but we want to avoid algebraic mechanics and look at things more conceptually, so we'll opt for the more revealing perspective that linear algebra provides. Linear algebra gives us a new tool, the <strong>matrix</strong>, which together with matrix–vector multiplication, gives a way to extract the coefficients from a linear combination of vectors:</p>
<div class="arithmatex">\[\begin{align*}
    E - A &amp;= \begin{bmatrix}
        | &amp; | \\
        -\mathbf{\hat{d}} &amp; (B - A) \\
        | &amp; | \\
    \end{bmatrix}\begin{bmatrix}
        t \\
        u
    \end{bmatrix} \\
    &amp;= \begin{bmatrix}
        -\hat{d}_x &amp; B_x - A_x \\
        -\hat{d}_y &amp; B_y - A_y \\
    \end{bmatrix}\begin{bmatrix}
        t \\
        u
    \end{bmatrix} \\
    &amp;= \mathbf{M}\begin{bmatrix}
        t \\
        u
    \end{bmatrix}
\end{align*}\]</div>
<p>We can think of multiplying a vector on the left by the matrix <span class="arithmatex">\(\mathbf{M}\)</span> as a transforming it from solution space (all possible <span class="arithmatex">\(t\)</span>–<span class="arithmatex">\(u\)</span> pairs) to a vector in physical space. The convention for denoting this translation between spaces is to define the column vectors of the matrix as a set called a <strong>basis</strong>:</p>
<div class="arithmatex">\[\beta = \{-\mathbf{\hat{d}}, B - A\}\]</div>
<p>We can then denote <span class="arithmatex">\(\mathbf{M}\mathbf{u}\)</span> as <span class="arithmatex">\([\mathbf{u}]_\beta\)</span>. This is called a <strong>change of basis</strong>. It may not be obvious at first, but the vector <span class="arithmatex">\((t, u)\)</span> is the coordinates of the vector <span class="arithmatex">\(E - A\)</span> in solution space, i.e., <span class="arithmatex">\((t, u) = [E - A]_\beta\)</span>.</p>
<p>So, we have a way to convert points in solution space into points in physical space. This would be great if we already had a solution, but we want to <em>find</em> the solution. How can we do this? Imagine a function <span class="arithmatex">\(f\)</span>:</p>
<div class="arithmatex">\[f(\mathbf{u}) = \mathbf{M}\mathbf{u}\]</div>
<p>If we could find the inverse of this function, then we should be able to move from physical space to solution space. This would let us use what we know about the objects in physical space to find the solution to our problem:</p>
<div class="arithmatex">\[\begin{bmatrix}
    t \\
    u
\end{bmatrix} = f^{-1}(E - A)\]</div>
<p>Luckily, matrices have an analogous idea: the <strong>matrix inverse</strong>:</p>
<div class="arithmatex">\[\begin{bmatrix}
    t \\
    u
\end{bmatrix} = \mathbf{M}^{-1}(E - A)\]</div>
<p>You can visualize this transformation in either direction by dragging the slider back and forth:</p>
<iframe src="https://www.desmos.com/calculator/p2c4zrtccu?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I've drawn only a few grid lines to improve performance. I've also played kind of fast and loose with the labelling, but this is meant to just give a sense for what is happening rather than a rigorous representation.</p>
</div>
<p>We're not going to worry about the mechanics of finding a matrix inverse. There is a plethora of resources on the various methods online. However, it is important to note that an inverse isn't guaranteed. There some conditions (most of which turn out to be equivalent) that have to be met for an inverse to exist. One of the conditions is that the matrix is square. This is a huge topic and we aren't going to go into it here, but it is related to why the 2D analog to a triangle is a segment. We are working in 2D, so the matrix has two rows. Thus, we need two columns, i.e., two basis vectors. Our basis vectors are defined by our ray, and the object it intersects (this will come back later in the 3D version). For this condition to be met, the problem needs to be set up correctly from the beginning, so doesn't actually have much to do with solving the problem.</p>
<p>Another condition for invertibility is that the column vectors be linearly independent. For only two vectors, this is the same as saying they are <em>not</em> parallel. Recall this was one of our miss conditions. This gives us our first way to check for a miss: <em>if we can't find an inverse, the ray misses</em>.</p>
<p>Our inverse, however, has no sense of our function domains, and as long as our direction is well-defined, <span class="arithmatex">\(A \neq B\)</span>, and <span class="arithmatex">\(\mathbf{\hat{d}}\)</span> is not parallel to <span class="arithmatex">\(B - A\)</span>, our matrix should have an inverse. This inverse matrix gives will translate <span class="arithmatex">\(E - A\)</span> into the parameters of the candidate point we talked about earlier. Then, all that is left is checking whether or not <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span> are within their respective ranges:</p>
<div class="arithmatex">\[t \geq 0, 0 \leq u \leq 1\]</div>
<p>That's it! We've solve the 2D ray–line segment intersection problem. To summarize:</p>
<ol>
<li>Create the matrix <span class="arithmatex">\(\mathbf{M}\)</span> from what is known about the ray and line segment</li>
<li>Attempt to find the matrix inverse. If an inverse doesn't exist, exit with a miss</li>
<li>Compute <span class="arithmatex">\(\mathbf{M}^{-1}(E - A)\)</span>:<ul>
<li>If <span class="arithmatex">\(t &lt; 0\)</span>, exit with a miss</li>
<li>If <span class="arithmatex">\(u &lt; 0\)</span>, exit with a miss</li>
<li>If <span class="arithmatex">\(u &gt; 1\)</span>, exit with a miss</li>
</ul>
</li>
<li>Return <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span></li>
</ol>
<p>Finally, a visualization of what the solution looks like:</p>
<iframe src="https://www.desmos.com/calculator/bsioqovkq0?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h2 id="translating-back-to-3d">Translating Back to 3D</h2>
<p>Although we started thinking about the problem of triangles in 3D and arrived at a 2D analog involving line segments, translating back to 3D may not naturally lead us back to triangles—at least not right away. Let's think about how to most naturally extend the problem we just solved to 3D before moving on to triangles.</p>
<details class="question">
<summary>Is 3D ray-line segment intersection possible?</summary>
<p>It turns out that this doesn't work, at least not using the methods in this article. I will leave it as homework to try and figure out why. I'll show you how I think of it in a follow-up post.</p>
</details>
<p>Recall our line segment equation:</p>
<div class="arithmatex">\[S(u) = A + u(B - A), \quad 0 \leq u \leq 1\]</div>
<p>What is the most natural way to extend this line segment to 3D? To answer this, let's change our perspective on what your line segment is. A line segment lives on a line, as we've already seen. Lines in 2D space can be thought of as 1D subspaces. When a subspace is one dimension lower than surrounding space, it is called a <strong>hyperplane</strong>. We can then think of a line segment as a hyperplane in 2D that is bounded along its only axis.</p>
<p>In this sense, the natural extension of a line segment to 3D would be a hyperplane in 3D (i.e., a plane) that is bounded along <em>both</em> its axes. Think back to our discussion of basis vectors. We have a single basis vector that spans all of 1D space, so to span our plane, we need another, linearly independent basis vector. We could add any vector and a scaling parameter to accomplish this, but since we are working toward a triangle, it makes sense to add a third point <span class="arithmatex">\(C\)</span> and create our second basis vector relative to it: <span class="arithmatex">\(C - A\)</span>. This gives the following function for our new shape:</p>
<div class="arithmatex">\[P(u, v) = A + u(B - A) + v(C - A), \quad 0 \leq u, v \leq 1\]</div>
<p>What is this shape? Let's start following a path around the outside and see if we can figure it out. <span class="arithmatex">\(P(0, 0) = A\)</span>. This will be our starting point. As we increase <span class="arithmatex">\(u\)</span> from 0 to 1, we travel along the path <span class="arithmatex">\(B - A\)</span> towards <span class="arithmatex">\(B\)</span>. <span class="arithmatex">\(P(1, 0) = B\)</span>. From here, as we increase <span class="arithmatex">\(v\)</span> from 0 to 1, we travel along the path <span class="arithmatex">\(C - A\)</span> toward a new point. Let's call it <span class="arithmatex">\(D\)</span>. Now, we start decreasing <span class="arithmatex">\(u\)</span> again. This causes us to move toward <span class="arithmatex">\(C\)</span> along the path <span class="arithmatex">\(A - B\)</span>. Recall, this is just the opposite direction as <span class="arithmatex">\(B - A\)</span>, so is parallel. We arrive at <span class="arithmatex">\(C\)</span>, and if we complete the trip by decreasing <span class="arithmatex">\(v\)</span> back to 0, we'll travel along <span class="arithmatex">\(A - C\)</span> (parallel to <span class="arithmatex">\(C - A\)</span>) until we arrive back at <span class="arithmatex">\(A\)</span>. So, we have a shape with four points and four sides where opposite sides are parallel. It's a <strong>parallelogram</strong>!</p>
<iframe src="https://www.desmos.com/calculator/szi2ytwaai?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<h2 id="parallelogram-mollertrumbore">Parallelogram Möller–Trumbore</h2>
<p>Before moving on to triangles, we're going to solve the parallelogram version of MT first. I think it is easier to understand and the extension to triangles is very simple. Parallelogram MT is almost identical to 2D MT, so we're not going to dwell on the details:</p>
<div class="arithmatex">\[\begin{align*}
    R(t) &amp;= T(u, v) \\
    E + t\mathbf{\hat{d}} &amp;= A + u(B - A) + v(C - A) \\
    E - A &amp;= t(-\mathbf{\hat{d}}) + u(B - A) + v(C - A) \\
    &amp;= \begin{bmatrix}
        | &amp; | &amp; | \\
        -\mathbf{\hat{d}} &amp; (B - A) &amp; (C - A) \\
        | &amp; | &amp; |
    \end{bmatrix}\begin{bmatrix}
        t \\
        u \\
        v
    \end{bmatrix} \\
    &amp;= \begin{bmatrix}
        -\hat{d}_x &amp; B_x - A_x &amp; C_x - A_x \\
        -\hat{d}_y &amp; B_y - A_y &amp; C_y - A_y \\
        -\hat{d}_z &amp; B_z - A_z &amp; C_z - A_z
    \end{bmatrix}\begin{bmatrix}
        t \\
        u \\
        v
    \end{bmatrix} \\
    &amp;= \mathbf{M}\begin{bmatrix}
        t \\
        u \\
        v
    \end{bmatrix} \\
    \begin{bmatrix}
        t \\
        u \\
        v
    \end{bmatrix} &amp;= \mathbf{M}^{-1}(E - A) \\
\end{align*}\]</div>
<p>It is then exactly like the 2D, but we have one additional check to make:</p>
<div class="arithmatex">\[0 \leq v \leq 1\]</div>
<p>Conceptually, everything works very much the same:</p>
<ul>
<li>If the ray and parallelogram are parallel, this is an obvious miss.</li>
<li>If they are not, then the line that the ray lies on intersects the plane that the parallelogram lies on in exactly one point. This is a candidate point for an intersection.</li>
<li>If the ray is pointing away from the parallelogram it misses. This corresponds to <span class="arithmatex">\(t\)</span> being negative.</li>
<li>If the ray is pointing towards the plane of the parallelogram, but <span class="arithmatex">\(u\)</span> or <span class="arithmatex">\(v\)</span> are out of ranges, the ray has missed, but now there are four edges it can pass by instead of two ends.</li>
</ul>
<script src="https://www.geogebra.org/apps/deployggb.js"></script>
<div id="ggb-para-mt" style="width: 100%; height: 300px"></div>
<script>
    var params = {
        "appName": "3D", 
        "material_id": "ma3taknq",
        "autoHeight": true,
        "transparentGraphics": true,
        "borderColor": "#FF000000",
    }
    var ggbParaMTApplet = new GGBApplet(params, true)
    window.addEventListener("load", function() { 
        ggbParaMTApplet.inject('ggb-para-mt')
    })
</script>

<h2 id="extending-to-triangles">Extending to Triangles</h2>
<p>Extending to triangles is very simple, but requires some explanation. Imagine we create a new function <span class="arithmatex">\(\tilde{T}\)</span> based on our parallelogram, but with <span class="arithmatex">\(u\)</span> fixed at <span class="arithmatex">\(1 - v\)</span>:</p>
<div class="arithmatex">\[\tilde{T}(v) = A + (1 - v)(B - A) + v(C - A), \quad 0 \leq v \leq 1\]</div>
<p>Notice this looks a lot like linear interpolation. Imagine starting <span class="arithmatex">\(\tilde{T}(0) = B\)</span>. As we increase <span class="arithmatex">\(v\)</span> from 0 to 1, our <span class="arithmatex">\(B - A\)</span> vector is scaled down by the same amount <span class="arithmatex">\(C - A\)</span> is scaled up, so <span class="arithmatex">\(\tilde{T}\)</span> travels from <span class="arithmatex">\(B\)</span> to <span class="arithmatex">\(C\)</span> in a straight line. This line creates a triangle with <span class="arithmatex">\(AB\)</span> and <span class="arithmatex">\(AC\)</span>. Now, we just need to incorporate the interior points.</p>
<iframe src="https://www.desmos.com/calculator/uizbpjechl?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<p>Let's reintroduce <span class="arithmatex">\(u\)</span>, but keep its relationship to <span class="arithmatex">\(v\)</span> in the form of a constraint:</p>
<div class="arithmatex">\[\tilde{T}(u, v) = A + u(B - A) + v(C - A), \quad 0 \leq u, v \leq 1, u + v = 1\]</div>
<p>As long as our <span class="arithmatex">\(u + v = 1\)</span> condition holds, all points of <span class="arithmatex">\(\tilde{T}\)</span> will be along the diagonal from <span class="arithmatex">\(B\)</span> to <span class="arithmatex">\(C\)</span>. Now, consider what happens if from any point along this line, we reduce <span class="arithmatex">\(u\)</span> or <span class="arithmatex">\(v\)</span>. The point gets closer to <span class="arithmatex">\(A\)</span>. Conversely, if we increase <span class="arithmatex">\(u\)</span> or <span class="arithmatex">\(v\)</span>, the point gets closer to <span class="arithmatex">\(D\)</span>. This tells use that we only have to make sure the sum of <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span> never gets <em>bigger</em> than 1:</p>
<div class="arithmatex">\[T(u, v) = A + u(B - A) + v(C - A), \quad 0 \leq u, v \leq 1, u + v \leq 1\]</div>
<p>And we have a formula for any point on or inside a triangle that mirrors our parallelogram. In fact, it only differs by a single constraint.</p>
<p>Try moving the point around and see what happens and when certain conditions fail. See if you can notice an interesting pattern:</p>
<iframe src="https://www.desmos.com/calculator/mjyebwcbtj?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More commonly, we define <span class="arithmatex">\(w = 1 - u - v\)</span>, and check <span class="arithmatex">\(w \geq 0\)</span>. Why? <span class="arithmatex">\(u\)</span>, <span class="arithmatex">\(v\)</span>, and <span class="arithmatex">\(w\)</span> define what are called barycentric coordinates. <span class="arithmatex">\(u\)</span>, <span class="arithmatex">\(v\)</span>, and <span class="arithmatex">\(w\)</span>, tell us how close we are to <span class="arithmatex">\(B\)</span>, <span class="arithmatex">\(C\)</span>, and <span class="arithmatex">\(A\)</span>, respectively. I'd like to make a whole post on barycentric coordinates at some point.</p>
</div>
<h2 id="summary">Summary</h2>
<p>This was a long, meandering approach to learning this algorithm, so I'd like to take a minute to summarize the full 3D triangle MT algorithm:</p>
<ol>
<li>Construct the matrix <span class="arithmatex">\(\mathbf{M}\)</span> with column vectors <span class="arithmatex">\(-\mathbf{\hat{d}}\)</span>, <span class="arithmatex">\(B - A\)</span>, and <span class="arithmatex">\(C - A\)</span>.</li>
<li>Attempt to find the matrix inverse, <span class="arithmatex">\(\mathbf{M}^{-1}\)</span>. If an inverse doesn't exist, exit with a miss.</li>
<li>Compute <span class="arithmatex">\(\mathbf{M}^{-1}(E - A)\)</span>. If any of the following conditions are met, exit with a miss:<ul>
<li><span class="arithmatex">\(t &lt; 0\)</span></li>
<li><span class="arithmatex">\(u &lt; 0\)</span></li>
<li><span class="arithmatex">\(u &gt; 1\)</span></li>
<li><span class="arithmatex">\(v &lt; 0\)</span></li>
<li><span class="arithmatex">\(v &gt; 1\)</span></li>
<li><span class="arithmatex">\(u + v &gt; 1\)</span></li>
</ul>
</li>
<li>Return <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(u\)</span></li>
</ol>
<script src="https://www.geogebra.org/apps/deployggb.js"></script>
<div id="ggb-tri-mt" style="width: 100%; height: 300px"></div>
<script>
    var params = {
        "appName": "3D", 
        "material_id": "cu6u5zwn",
        "autoHeight": true,
        "transparentGraphics": true,
        "borderColor": "#FF000000",
    }
    var ggbTriMTApplet = new GGBApplet(params, true)
    window.addEventListener("load", function() { 
        ggbTriMTApplet.inject('ggb-tri-mt')
    })
</script>

<h2 id="a-basic-python-implementation">A Basic Python Implementation</h2>
<div class="admonition warning">
<p class="admonition-title">This implementation uses numpy</p>
<p>You will need to make sure you have numpy installed for this to work</p>
</div>
<p>The most common way to handle intersections in ray tracing code is to have the <code>intersect</code> function return the value of <span class="arithmatex">\(t\)</span> associated with the intersection. To recover the point, just use the <code>at</code> function, which returns a point on the ray.</p>
<p>Since <span class="arithmatex">\(t\)</span> must be non-negative, a common way to encode misses is as a -1. However, I prefer to raise an exception, because I find it makes things a lot clearer when the return value of a function only has one meaning. The <code>intersect</code> function returns the <span class="arithmatex">\(t\)</span> value of the intersection. Since -1 is not a valid <span class="arithmatex">\(t\)</span> value, it is confusing to return this. Instead, since there is no valid <span class="arithmatex">\(t\)</span> value for a miss, we raise an exception. This is somewhat analogous to a division by zero error.</p>
<div class="highlight"><span class="filename">mt.py</span><pre><span></span><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">class</span> <span class="nc">DoNotIntersectException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">Triangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Ray</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="c1"># Check direction makes sense</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ambiguous direction&quot;</span><span class="p">)</span>

        <span class="c1"># Assure unit length</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">:</span> <span class="n">Triangle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an object, returns the distance from the ray origin to the</span>
<span class="sd">        point of intersection with the object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Triangle</span><span class="p">):</span>
            <span class="c1"># Create matrix transform from solutions space to physical space</span>
            <span class="n">soln_to_phys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span>
                                            <span class="nb">object</span><span class="o">.</span><span class="n">B</span> <span class="o">-</span> <span class="nb">object</span><span class="o">.</span><span class="n">A</span><span class="p">,</span>
                                            <span class="nb">object</span><span class="o">.</span><span class="n">C</span> <span class="o">-</span> <span class="nb">object</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
            <span class="c1"># Attempt to invert</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">phys_to_soln</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">soln_to_phys</span><span class="p">)</span>

            <span class="c1"># Coplanar direction and triangle</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DoNotIntersectException</span><span class="p">()</span>

            <span class="c1"># Transform vector from A to ray origin into solution</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">phys_to_soln</span><span class="o">@</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="nb">object</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>

            <span class="c1"># Check domains</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t</span>

        <span class="k">raise</span> <span class="n">DoNotIntersectException</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a distance, returns a point at that distance away from the</span>
<span class="sd">        origin along the ray.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

    <span class="n">ray</span> <span class="o">=</span> <span class="n">Ray</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="n">values</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="n">Triangle</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">12</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="mi">12</span><span class="p">:</span><span class="mi">15</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">triangle</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
<p>I have included a very simple CLI to manually test the implementation.</p>
<p>Usage:</p>
<div class="highlight"><pre><span></span><code>python mt.py ex ey ez dx dy dz ax ay az bx by bz cx cy cz
</code></pre></div>
<p>Example:</p>
<div class="highlight"><pre><span></span><code>python mt.py 1 1 1 1 1 2 1 1 2 3 2 2 2 3 3
</code></pre></div>
<p>This should return <code>1.4696938456699067</code>.</p>]]></description>
        <link>https://trslater.ca/blog-base-two/2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/</link>
        <guid>https://trslater.ca/blog-base-two/2023/08/15/mollertrumbore-photorealistic-lighting-starts-with-a-ray-and-a-triangle/</guid>
        <pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate>
    </item>
    
</channel>
</rss>